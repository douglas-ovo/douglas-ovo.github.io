---
title: js数据结构与算法
categories:
  - 前端学习
tags:
  - 数据结构
  - 算法
date: 2022-07-15 14:28:47
index_img:  https://img2.baidu.com/it/u=2993686411,2188442933&fm=253&fmt=auto&app=138&f=JPEG?w=651&h=391
---

### 数据结构与算法(Data structure and algorithm)

### 什么是数据结构

计算机中存储和组织数据的方式

就好比庞大的图书馆，不仅要合理的把书放进去，还要能高效的取出来

不能说那个数据结构比另一个数据结构好，因为每种数据结构都有自己特定的应用场景

### 什么是算法

解决问题的办法/步骤逻辑

数据结构的实现，离不开算法

### 栈(Stack)

数组是不受限的线性结构，可以在任意位置插入和删除数据

为了实现某些功能，必须对任意性加以限制；栈和队列就是常见的受限的线性结构

限制是仅允许在表的一端进行插入和删除运算，这一端成为栈顶，另一端为栈底

LIFO(last in first out)后进先出

向栈插入新元素称为进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素

从栈中删除元素称为出栈或退栈，是把栈顶元素删除，使其相邻的元素成为新的栈顶元素

生活中的栈，如：自助餐的托盘

程序中的栈，如：函数相互调用(函数调用栈)，A调用B, B中又调用C，C中又调用D，当前栈的顺序，栈底A->B->C->D栈顶，D执行完一次弹出栈

![栈的面试题](/img/sample/a011/1.%E6%A0%88%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.png)

```javascript
      /* 
            两种实现栈的方式：基于数组实现；基于链表实现
        */

      //基于数组实现栈
      class Stack {
          constructor() {
              this.items = []
          }
          push(element) { //添加一个新元素到栈顶
              this.items.push(element)
          }
          pop() { //移除栈顶元素，同时返回被移除的元素
              return this.items.pop()
          }
          peek() { //返回栈顶元素
              return this.items[this.items.length - 1]
          }
          isEmpty() { //判断栈是否为空
              return this.items.length === 0
          }
          size() { //返回栈中元素个数
              return this.items.length
          }
          toString() { //将栈结构的内容以字符形式返回
              let str = ''
              this.items.forEach(item => {
                  str += item + ' '
              })
              return str
          }
      }
      let s1 = new Stack()
      console.log(s1);
      s1.push(20)
      s1.push(10)
      console.log(s1.size());
      console.log(s1.toString());

      //十进制转二进制
      function dec2bin(decNum) {
          let stack = new Stack()
          while (decNum > 0) {
              stack.push(decNum % 2)
              decNum = Math.floor(decNum / 2)
          }

          let binNum = ''
          while (!stack.isEmpty()) {
              binNum += stack.pop()
          }
          return binNum
      }
      console.log(dec2bin(100));
```

### 队列(Queue)

FIFO(first in first out)先进先出

限制是只允许在表的前端进行删除操作，在表的后端进行插入操作

优先级队列：插入元素时会将该数据的优先级和其他数据的优先级进行比较，得出该元素在队列中的正确位置

生活中的优先级队列：头等舱、商务舱、经济舱；急诊科和普通诊室

程序中的优先级队列：线程中处理任务的优先级

```javascript
        /* 
            两种实现队列的方式：基于数组实现；基于链表实现 
        */

        //基于数组实现队列
        class Queue {
            items = []
            enqueue(element) { //向队尾添加一个或多个元素
                this.items.push(element)
            }
            dequeue() { //移除队列第一项，并返回被移除的元素
                return this.items.shift()
            }
            front() { //返回队列第一个元素
                return this.items[0]
            }
            isEmpty() {
                return this.items.length === 0
            }
            size() {
                return this.items.length
            }
            toString() {
                let str = ''
                this.items.forEach(item => {
                    str += item + ''
                })
                return str
            }
        }
        let q1 = new Queue()

        //击鼓传花
        function passGame(nameList, num) {
            let queue = new Queue()
            nameList.forEach(item => {
                queue.enqueue(item)
            })
            while (queue.size() > 1) {
                for (let i = 0; i < num - 1; i++) {
                    queue.enqueue(queue.dequeue())
                }
                queue.dequeue()
            }
            console.log(nameList.indexOf(queue.front()));
            return queue.front()
        }
        console.log(passGame(['lt', 'tb', 'cm', 'xml'], 3));

        //优先级队列
        class QueueElement {
            constructor(element, priority) {
                this.element = element
                this.priority = priority
            }
        }

        class PriorityQueue {
            items = []
            enqueue(element, priority) {
                let queueElement = new QueueElement(element, priority)
                if (this.items.length === 0) {
                    this.items.push(queueElement)
                } else {
                    let flag = false
                    this.items.forEach((item, index) => {
                        if (queueElement.priority < item.priority) {
                            this.items.splice(index, 0, queueElement)
                            flag = true
                            return
                        }
                    })

                    if (!flag) {
                        this.items.push(queueElement)
                    }
                }
            }
            dequeue() { //移除队列第一项，并返回被移除的元素
                return this.items.shift()
            }
            front() { //返回队列第一个元素
                return this.items[0]
            }
            isEmpty() {
                return this.items.length === 0
            }
            size() {
                return this.items.length
            }
            toString() {
                let str = ''
                this.items.forEach(item => {
                    str += item.priority + '---' + item.element + '\n'
                })
                return str
            }
        }

        let pq = new PriorityQueue()
        pq.enqueue('a', 10)
        pq.enqueue('b', 1)
        pq.enqueue('c', 100)
        // pq.enqueue('d', 2)
        console.log(pq.toString());
```

### 链表(linked list)

数组创建需要申请一段连续的大小固定的内存空间，当不满足容量需求时，需要扩容。一般时申请一个更大的数组，将原数组复制过去。数组在开头或中间位置插入数据成本很高，需要进行大量的元素位移

链表不必是连续空间，可以充分利用计算机内存，实现内存动态管理

链表的每一个元素由一个存储元素本身的节点和指向下一个元素的引用(有些语言成为指针或连接)组成

不需要再创建时确定大小，并且大小可以无限的延伸

链表在插入和删除数据时，时间复~杂度可以达到O(1)，相对数组效率高很多

链表访问任何一个位置的元素时，都要从头开始访问，无法通过下标直接访问(无法跳过第一个元素访问任何一个元素)

![链表的结构](/img/sample/a011/2.%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

```javascript
        class Node {
            constructor(data) {
                this.data = data
                this.next = null
            }
        }

        class LinkedList {
            head = null
            length = 0

            append(data) {
                let newNode = new Node(data)
                if (this.length === 0) { //是第一个节点
                    this.head = newNode
                } else { //不是第一个节点
                    let current = this.head
                    while (current.next) { //从头找到最后一个节点
                        current = current.next
                    }
                    current.next = newNode
                }
                this.length += 1
            }

            toString() {
                let current = this.head //获取第一个节点
                let listString = ''
                while (current) {
                    listString += current.data + '--'
                    current = current.next
                }
                return listString
            }

            insert(position, data) {
                if (position < 0 || position > this.length) return false
                let newNode = new Node(data)
                if (position === 0) {
                    newNode.next = this.head
                    this.head = newNode
                } else {
                    let index = 0
                    let current = this.head
                    let previous = null;
                    while (index++ < position) { //找到之前同位置的元素,index++先判断后自加
                        previous = current
                        current = current.next
                    }
                    newNode.next = current
                    previous.next = newNode
                }
                this.length += 1
            }

            get(position) { //获取对应位置的data
                console.log(this.length);
                if (position < 0 || position >= this.length) return null
                let current = this.head
                let index = 0
                while (index++ < position) {
                    current = current.next
                }
                return current.data
            }

            indexOf(data) { //返回数据在链表中的索引
                let current = this.head
                let index = 0
                while (current) {
                    if (current.data === data) {
                        return index
                    }
                    current = current.next
                    index++
                }
                return -1
            }

            update(position, newData) { //修改某个位置的数据
                if (position < 0 || position >= this.length) return false
                let current = this.head
                let index = 0
                while (index++ < position) {
                    current = current.next
                }
                current.data = newData
                return true
            }

            removeAt(position) { //删除指定位置的节点
                if (position < 0 || position >= this.length) return false
                let current = this.head
                if (position === 0) {
                    this.head = this.head.next
                } else {
                    let index = 0
                    let previous = null
                    while (index++ < position) {
                        previous = current
                        current = current.next
                    }
                    previous.next = current.next
                }
                this.length -= 1
                return current.data
            }

            remove(data) { //删除指定data的节点
                let position = this.indexOf(data)
                this.removeAt(position)
            }

            isEmpty() {
                return this.length === 0
            }

            size() {
                return this.length
            }
        }

        list = new LinkedList()
        list.append('hello')
        console.log(list.toString());

        list.insert(0, 'hi')
        console.log(list.toString());

        console.log(list.get(1));

        console.log(list.indexOf('hello'));
        console.log(list.indexOf('he'));

        list.update(1, 'helloo')
        console.log(list.toString());

        list.append('bili')
        console.log(list.toString());
        console.log(list.removeAt(1));
        console.log(list.toString());

        list.remove('bili')
        console.log(list.toString());

        console.log(list.isEmpty());
        console.log(list.size());
```

### 双向链表(double linked list)

单项链表的缺点：可以很轻松的到达下一个节点，但是回到前一个节点很难

双向链表，一个节点既有向前连接的引用，又有一个向后连接的引用

双向链表的缺点：
  +   每次在插入或删除某个节点时，需要处理四个引用
  +   所占内存空间更大

结构：
  +   可以使用head和tail分别指向头部和尾部的节点
  +   每个节点由三部分组成：前一个节点的指针prev，保存的元素item，后一个节点的指针next
  +   第一个节点的prev是null，最后一个节点的next是null

![双向链表的结构](/img/sample/a011/3.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

```javascript
        class Node {
            prev = null
            next = null
            constructor(data) {
                this.data = data
            }
        }
        class DoubleLinkedList {
            head = null;
            tail = null;
            length = 0

            append(data) {
                let newNode = new Node(data)
                if (this.length === 0) { //是第一个节点
                    this.head = newNode
                } else {
                    let current = this.head
                    while (current.next) {
                        current = current.next
                    }
                    current.next = newNode
                    newNode.prev = current
                }
                this.tail = newNode
                this.length += 1
            }
            insert(positon, data) {
                if (positon < 0 || positon > this.length) return false
                let newNode = new Node(data)
                if (this.length === 0) {
                    this.head = newNode
                    this.tail = newNode
                } else {
                    if (positon === 0) {
                        newNode.next = this.head
                        this.head.prev = newNode
                        this.head = newNode
                    } else if (positon === this.length) {
                        newNode.prev = this.tail
                        this.tail.next = newNode
                        this.tail = newNode
                    } else {
                        let current = this.head
                        let index = 0
                        while (index++ < position) {
                            current = current.next
                        }
                        newNode.next = current
                        newNode.prev = current.prev
                        current.prev.next = newNode
                        current.prev = newNode
                    }
                }
                this.length++
            }
            get(position) {
                if (position < 0 || position >= this.length) return false
                //可以自己扩充
                //this.length/2 < position 从头查找
                //this.length/2 >position 从尾查找

                let current = this.head
                let index = 0
                while (index++ < position) {
                    current = current.next
                }
                return current.data
            }
            indexOf(data) {
                let current = this.head
                let index = 0
                while (current) {
                    if (current.data === data) {
                        return index
                    }
                    current = current.next
                    index++
                }
                return -1
            }
            update(position, newData) {
                if (position < 0 || position >= this.length) return false
                let current = this.head
                let index = 0
                while (index++ < position) {
                    current = current.next
                }
                current.data = newData
            }
            removeAt(position) {
                if (position < 0 || position >= this.length) return null
                let current = this.head
                if (this.length === 1) {
                    this.head = null
                    this.tail = null
                } else {
                    if (position === 0) {
                        this.head.next.prev = null
                        this.head = this.head.next
                    } else if (position === this.length - 1) {
                        current = this.tail
                        this.tail.next = null
                        this.tail = this.tail.prev
                    } else {
                        let index = 0
                        while (index++ < position) {
                            current = current.next
                        }
                        current.prev.next = current.next
                        current.next.prev = current.prev
                    }
                }
                this.length--
                return current.data
            }
            remove(data) {
                this.removeAt(this.indexOf(data))
            }
            isEmpty() {
                return this.length === 0
            }
            size() {
                return this.length
            }
            toString() {
                return this.backwardString()
            }
            getHead() {
                return this.head.data
            }
            getTail() {
                return this.tail.data
            }
            forwardString() {
                let current = this.tail
                let str = ''
                while (current) {
                    str += current.data + '00'
                    current = current.prev
                }
                return str
            }
            backwardString() {
                let current = this.head
                let str = ''
                while (current) {
                    str += current.data + '=='
                    current = current.next
                }
                return str
            }
        }
        let list = new DoubleLinkedList()
        list.append('h')
        list.append('i')
        console.log(list.backwardString());
        console.log(list.forwardString());
```

### 集合(set)

集合常见的实现方式是哈希表

集合通常是一组无序的，不能重复的元素构成

可以将集合看作特殊的数组，没有顺序意味着不能通过下标访问，不重复意味着相同的对象在集合中只有一份

![集合间的操作](/img/sample/a011/4.%E9%9B%86%E5%90%88%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C.png)

```javascript
        class Set {
            items = {}
            add(value) {
                if (this.has(value)) {
                    return false
                }
                this.items[value] = value
                return true
            }
            remove(value) {
                if (!this.has(value)) {
                    return false
                }
                delete this.items[value]
                return true
            }
            has(value) {
                return this.items.hasOwnProperty(value)
            }
            clear() {
                this.items = {}
            }
            size() {
                return Object.keys(this.items).length
            }
            values() {
                return Object.keys(this.items)
            }
            union(otherSet) {
                let unionSet = new Set()
                let values = this.values()
                for (let i = 0; i < this.size(); i++) {
                    unionSet.add(values[i])
                }
                values = otherSet.values()
                for (let i = 0; i < values.length; i++) {
                    unionSet.add(values[i])
                }
                return unionSet
            }
            intersection(otherSet) {
                let interSet = new Set()
                let values = this.values()
                for (let i = 0; i < values.length; i++) {
                    let item = values[i]
                    if (otherSet.has(item)) {
                        interSet.add(item)
                    }
                }
                return interSet
            }
            difference(otherSet) {
                let diffSet = new Set()
                let values = this.values()
                for (let i = 0; i < values.length; i++) {
                    let item = values[i]
                    if (!otherSet.has(item)) {
                        diffSet.add(item)
                    }
                }
                return diffSet
            }
            subset(otherSet) {
                let values = this.values()
                for (let i = 0; i < values.length; i++) {
                    let item = values[i]
                    if (!otherSet.has(item)) {
                        return false
                    }
                }
                return true
            }
        }

        //并集
        let set1 = new Set()
        set1.add('one_aaa')
        let set2 = new Set()
        set2.add('two_aaa')
        set2.add('one_aaa')
        console.log(set1.union(set2));
        console.log(set1.intersection(set2));
        console.log(set2.difference(set1));
        console.log(set1.subset(set2));
```

### 字典(dict)

数组、集合、字典几乎是所有编程语言默认提供的数据类型

类似于上面的集合，但是集合不是键值对的形式

```javascript
{
    age: 18,
    name: 'akman'
}
```

可以通过key-value取出

key是不可重复的，value可以重复，key是无须的

相当于js中的对象

### 哈希表(hash table)

哈希表通常是基于数组进行实现的，但是数据名称(单词)经过哈希函数的变换成了下标值，将该数据存到对应下标的数组中，通过下标值获取数据的效率非常高

相对数组它可以提供非常快速的插入、删除、查找操作

哈希表中的数据是没有顺序的，不能用一种固定的方式遍历其中的元素

缺点：
  +   哈希表中的key是不允许重复的；
  +   哈希表中的数据是没有顺序的(集合，字典的实现都是基于哈希表)；
  +   空间利用率不高；
  +   不能快速找到表中的特殊值，如：最大值、最小值

哈希化：
  +   将大数字转化成数组范围内下标的过程

哈希函数：
  +   通常我们会将单词转换成大数字，大数组哈希化的代码放在一个函数中，这个函数我们成为哈希函数

哈希表：
  +   最终将数据插入数组中，对整个结构进行封装，我们称之为一个哈希表

下表冲突解决：
  +   链地址法    
  链地址法解决冲突的办法是每个数组单元中的存储不再是单个数据，而是一个链条可以是数组也可以是链表

![链地址法](/img/sample/a011/5.%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png)

+   开放地址法
线性探测    index位置+1查找空白位置
二次探测
再哈希法

![开放地址法](/img/sample/a011/6.%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%951.png)

+   开发中使用链地址法更多

![哈希表的结构](/img/sample/a011/7.%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

实质上是一个三重数组

为什么需要扩容
  +   随着数据量增加，bucket会越来越长，哈希表效率降低

如何扩容
  +   可以简单的将容量扩大两倍(容量最好为质数，更利于数据的均匀分布)
  +   扩容时，所用数据项需要重新获取位置

```javascript
        class HashTable {
            storage = [] //存放元素的数组
            count = 0 //数据量    用于计算加载因子， loadfactor > 0.75时需要对数组进行扩容，<0.25时减容     加载因子=存储数据量/数组长度 
            limit = 7 //数组当前总长度

            hashFunc(str, size) {
                let hashCode = 0
                for (let i = 0; i < str.length; i++) {
                    hashCode = 37 * hashCode
                    hashCode = hashCode + str.charCodeAt(i)
                }
                let index = hashCode % size
                return index
            }
            put(key, value) { //插入和修改是同一个操作，原表没有就插入，原表有就修改
                let index = this.hashFunc(key, this.limit)
                let bucket = this.storage[index]
                if (!bucket) {
                    bucket = []
                    this.storage[index] = bucket
                }
                for (let i = 0; i < bucket.length; i++) {
                    let tuple = bucket[i] //元组
                    if (key === tuple[0]) {
                        tuple[1] = value
                        return
                    }
                }
                bucket.push([key, value])
                this.count++

                if (this.count > this.limit * 0.75) { //扩容
                    let newPrime = this.getPrime(this.limit * 2)
                    this.resize(newPrime)
                }
            }
            get(key) { //获取元素
                let index = this.hashFunc(key, this.limit)
                let bucket = this.storage[index]
                if (!bucket) return null
                for (let i = 0; i < bucket.length; i++) {
                    let tuple = bucket[i]
                    if (key === tuple[0]) return tuple[1]
                }
                return null
            }
            remove(key) {
                let index = this.hashFunc(key, this.limit)
                let bucket = this.storage[index]
                if (!bucket) return false
                for (let i = 0; i < bucket.length; i++) {
                    let tuple = bucket[i]
                    if (key === tuple[0]) {
                        bucket.splice(i, 1)
                        this.count--
                        return tuple[1]

                        if (this.limit > 7 && this.count < this.limit * 0.25) { //缩容
                            let newPrime = this.getPrime(Math.floor(this.limit / 2))
                            this.resize(newPrime)
                        }
                    }
                }
                return false
            }
            isEmpty() {
                return this.count === 0
            }
            size() {
                return this.count
            }
            resize(newLimit) { //扩容
                oldStorage = this.storage
                this.storage = []
                this.count = 0
                this.limit = newLimit
                for (let i = 0; i < oldStorage.length; i++) {
                    let bucket = oldStorage[i]
                    if (!bucket) continue //为空跳过本次循环
                    for (let j = 0; j < bucket.length; j++) {
                        let tuple = bucket[j]
                        this.put(tuple[0], tuple[1])
                    }
                }

            }
            isPrime(num) {
                let temp = parseInt(Math.sqrt(num))

                for (let i = 2; i < temp; i++) {
                    if (num % i === 0) return false
                }
                return true
            }
            getPrime(num) {
                while (!this.isPrime()) {
                    num++
                }
                return num
            }
        }

        let hashtable1 = new HashTable()
        hashtable1.put('dogulas', {
            age: 18,
            gender: 'male'
        })
        hashtable1.put('july', {
            age: 22,
            gender: 'famale'
        })
        // console.log(hashtable1);
        // console.log(hashtable1.get('july'));
        hashtable1.remove('dogulas')
        // console.log(hashtable1);
        // console.log(hashtable1.isEmpty());
        // console.log(hashtable1.size());
```

### 树结构(tree)

树结构是非线性的，可以表示一对多的关系

树结构的表示方法

> 普通表示法
> 儿子-兄弟表示法

相关术语

> 节点的度：节点的子树个数
> 树的度：树的所有节点中最大度数
> 路径和路径长度：路径所包含边的个数为路径的长度
> 节点的层次：根节点在1层，其他任意节点的层数是其父节点的层数+1
> 树的深度：树中所有节点中的最大层次是这棵树的深度 

二叉树：

> 如果树中每个节点最多只能有两个子节点，这样的数成为二叉树

> 任何树都可以用二叉树模拟出来

![树的本质-二叉树](/img/sample/a011/8.%E6%A0%91%E7%9A%84%E6%9C%AC%E8%B4%A8-%E4%BA%8C%E5%8F%89%E6%A0%91.png)

特性：

> 第i层的最大节点数为2^(i-1), i>=1
> 深度为k的二叉树最大节点总数为2^k-1, k>=1
> 对任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么两者满足关系n0=n2+1
> 完美二叉树；完全二叉树

二叉搜索树

> Binary search tree
> 非空左子树的所有键值小于其根节点的键值
> 非空右子树的所有键值大于其根节点的键值
> 左右子树本身也是二叉搜索树

![二叉搜索树的结构](/img/sample/a011/9.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84.png)

![先序遍历](/img/sample/a011/10.%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.png)

![中序遍历](/img/sample/a011/11.%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png)

![后序遍历](/img/sample/a011/12.%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png)

平衡树

> 树中每个节点左边的子孙节点的个数，应该尽可能等于右边的子孙节点个数
> 使其深度尽可能小，从而提高查找、插入、删除效率

红黑树

> 节点是红色或者黑色
> 根节点是黑色
> 每个叶子节点都是黑色的空节点(NIL节点)
> 每个红色节点的两个子节点都是黑色，从每个叶子到根的所有路径上不能有两个连续的红色节点
> 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
> 红黑树的平衡

  + 变色
  + 左旋转
  + 右旋转 

```javascript
        class Node {
            left = null
            right = null
            constructor(key) {
                this.key = key
            }
        }
        class BinarySearchTree {
            root = null
            //插入
            insert(key) {
                let newNode = new Node(key)
                if (this.root === null) {
                    this.root = newNode
                } else {
                    this.insertNode(this.root, newNode)
                }
            }
            insertNode(node, newNode) { //私有方法  递归函数(其实就是一个压栈过程)  递归基本都可以转成循环
                if (newNode.key < node.key) { //向左查找
                    if (node.left === null) {
                        node.left = newNode
                    } else {
                        this.insertNode(node.left, newNode)
                    }
                } else { //向右查找
                    if (node.right === null) {
                        node.right = newNode
                    } else {
                        this.insertNode(node.right, newNode)
                    }
                }
            }

            //查找是否含有某值
            search(key) {
                let node = this.root
                while (node !== null) { //递归代码简单，空间复杂度高；循环代码复杂，空间复杂度低
                    if (key < node.key) {
                        node = node.left
                    } else if (key > node.key) {
                        node = node.right
                    } else {
                        return true
                    }
                }
                return false
            }

            //中序遍历  中间处理root    访问顺序node.left->node->node.right
            inOrderTraverse(handler) {
                this.inOrderTraverseNode(this.root, handler)
            }
            inOrderTraverseNode(node, handler) {
                if (node !== null) {
                    this.inOrderTraverseNode(node.left, handler)
                    handler(node.key)
                    this.inOrderTraverseNode(node.right, handler)
                }
                return
            }

            //先序遍历  先处理root   访问顺序node->node.left->node.right
            preOrderTraverse(handler) {
                this.preOrderTraverseNode(this.root, handler)
            }
            preOrderTraverseNode(node, handler) { //私有方法
                if (node !== null) {
                    handler(node.key)
                    this.preOrderTraverseNode(node.left, handler)
                    this.preOrderTraverseNode(node.right, handler)
                }
                return
            }

            //后序遍历  后处理root
            postOrderTraverse(handler) {
                this.postOrderTraverseNode(this.root, handler)
            }
            postOrderTraverseNode(node, handler) {
                if (node !== null) {
                    this.postOrderTraverseNode(node.left, handler)
                    this.postOrderTraverseNode(node.right, handler)
                    handler(node.key)
                }
                return
            }

            //最大最小值
            min() {
                let node = this.root
                while (node.left !== null) {
                    node = node.left
                }
                return node.key
            }
            max() {
                let node = this.root
                while (node.right !== null) {
                    node = node.right
                }
                return node.key
            }

            //删除节点
            remove(key) {
                let current = this.root
                let parent = null
                let isLeft = true //current 是左节点还是右节点

                while (current.key !== key) {
                    parent = current
                    if (key < current.key) {
                        isLeft = true
                        current = current.left
                    } else {
                        isLeft = false
                        current = current.right
                    }

                    if (current === null) return false
                }

                //删除节点是叶子节点
                if (current.left === null && current.right === null) {
                    if (current === this.root) {
                        this.root = null
                    } else if (isLeft) {
                        parent.left = null
                    } else {
                        parent.right = null
                    }
                }

                //删除节点有一个子节点
                else if (current.right === null) {
                    if (current === this.root) {
                        this.root = current.left
                        return
                    }

                    if (isLeft) {
                        parent.left = current.left
                    } else {
                        parent.right = current.left
                    }
                } else if (current.left === null) {
                    if (current === this.root) {
                        this.root = current.right
                        return
                    }

                    if (isLeft) {
                        parent.left = current.right
                    } else {
                        parent.right = current.right
                    }
                }

                //删除节点有两个子节点
                else {
                    let successor = this.getSuccessor(current)
                    if (current === this.root) {
                        this.root = successor
                        return
                    }
                    if (isLeft) {
                        parent.left = successor
                    } else {
                        parent.right = successor
                    }

                    successor.left = current.left
                }
            }
            getSuccessor(delNode) {
                let successor = delNode
                let current = delNode.right
                let successorParent = delNode
                while (current !== null) {
                    successorParent = successor
                    successor = current
                    current = current.left
                }
                if (successor !== delNode.right) {
                    successorParent.left = successor.right
                    successor.right = delNode.right
                }
                return successor
            }

        }

        const bst = new BinarySearchTree()
        bst.insert(8)
        bst.insert(7)
        bst.insert(15)
        bst.insert(5)
        bst.insert(3)
        bst.insert(9)
        bst.insert(10)
        // console.log(bst);

        let preStr = '^'
        bst.preOrderTraverse((key) => { //闭包
            preStr += key + '=='
        })
        console.log(preStr);

        let inStr = '*'
        bst.inOrderTraverse((key) => {
            inStr += key + '=='
        })
        console.log(inStr);

        let postStr = '$'
        bst.postOrderTraverse((key) => {
            postStr += key + '=='
        })
        console.log(postStr);

        // console.log(bst.min());
        // console.log(bst.max());

        // console.log(bst.search(25));
        // console.log(bst.search(15));
        bst.remove(7)
        let str = ''
        bst.inOrderTraverse((key) => {
            str += key + '=='
        })
        console.log(str);
```

### 图(Graph)

图主要研究事物之间的关系，顶点代表事物，边代表两个事物间的关系

通常用V(vertex)表示顶点的集合

通常用E(Edge)表示边的集合

> 边是顶点和顶点之间的连线
> 边可以是有向的，也可以是无向

欧拉七桥问题

> 连接一点的边的数目如果是奇数条，就成为奇点；偶数条则为偶点

相关术语

> 度：一个顶点相邻顶点的个数
> 简单路径：路径不包含重复的顶点
> 回路：第一个顶点和最后一个顶点相同的路径
> 无向图和有向图(边是否带有方向)
> 无权图和有权图(边是否带有权重)

邻接矩阵

> 每个节点和一个整数相关联，该整数作为数组的下标
> 用二维数组表示顶点之间的连接 

![邻接矩阵](/img/sample/a011/13.%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png)


> 缺点：如果是稀疏图(边很少)，还是需要大量的0表示不存在的边，造成空间浪费

邻接表

> 每个顶点以及和顶点相邻的顶点列表组成
> 类似于hash表

![邻接表](/img/sample/a011/14.%E9%82%BB%E6%8E%A5%E8%A1%A8.png)

> 出度：指向别人的数量；入度：指向自己的数量
> 缺点：出度好计算；入度不好计算，不需构建一个逆邻接表，才能有效的计算入度，开发中计算入度较少

```javascript
        class Dictionary { //字典
            items = {}

            set(key, value) {
                this.items[key] = value
            }
            has(key) {
                return this.items.hasOwnProperty(key)
            }
            remove(key) {
                if (!this.has(key)) return false
                delete this.items[key]
                return true
            }
            get(key) {
                return this.has(key) ? this.items[key] : undefined
            }
            keys() {
                return Object.keys(this.items)
            }
            values() {
                return Object.values(this.items)
            }
            size() {
                return this.keys.length
            }
            clear() {
                this.items = {}
            }
        }

        class Queue {
            items = []
            enqueue(element) { //向队尾添加一个或多个元素
                this.items.push(element)
            }
            dequeue() { //移除队列第一项，并返回被移除的元素
                return this.items.shift()
            }
            front() { //返回队列第一个元素
                return this.items[0]
            }
            isEmpty() {
                return this.items.length === 0
            }
            size() {
                return this.items.length
            }
            toString() {
                let str = ''
                this.items.forEach(item => {
                    str += item + ''
                })
                return str
            }
        }

        class Graph {
            vertexes = [] //顶点
            edges = new Dictionary() //边

            addVertexes(v) {
                this.vertexes.push(v)
                this.edges.set(v, [])
            }
            addEdge(v1, v2) {
                this.edges.get(v1).push(v2)
                this.edges.get(v2).push(v1) //无向图
            }
            toString() {
                let str = ''
                this.vertexes.forEach(item => {
                    str += item + ' -> '
                    let vEdge = this.edges.get(item)
                    vEdge.forEach(ite => {
                        str += ite + ' '
                    })
                    str += '\n'
                })
                return str
            }
            initializeColor() { //遍历时 顶点状态颜色   white没有被访问   gray被访问但未被探索    black被访问且被完全探索
                let colors = {}
                this.vertexes.forEach((item) => {
                    colors[item] = 'white'
                })
                return colors
            }
            bfs(initV, handler) { //广度优先搜索
                let colors = this.initializeColor()
                let queue = new Queue()
                queue.enqueue(initV)
                while (!queue.isEmpty()) {
                    let v = queue.dequeue()
                    let vList = this.edges.get(v)
                    colors[v] = 'gray'
                    vList.forEach(item => {
                        if (colors[item] === 'white') {
                            colors[item] = 'gray'
                            queue.enqueue(item)
                        }
                    })
                    handler(v)
                    colors[v] = 'black'
                }
            }
            dfs(initV, handler) { //深度优先搜索
                let colors = this.initializeColor()
                this.dfsVisit(initV, colors, handler)
            }
            dfsVisit(v, colors, handler) { //私有方法，递归函数
                colors[v] = 'gray'
                handler(v)
                let vList = this.edges.get(v)
                vList.forEach(item => {
                    if (colors[item] === 'white') {
                        colors[item] = 'gray'
                        this.dfsVisit(item, colors, handler)
                    }
                })
                colors[v] = 'black'
            }
        }

        let g1 = new Graph()
        const varr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
        varr.forEach(item => {
            g1.addVertexes(item)
        })
        g1.addEdge('A', 'B')
        g1.addEdge('A', 'C')
        g1.addEdge('A', 'D')
        g1.addEdge('C', 'D')
        g1.addEdge('C', 'G')
        g1.addEdge('D', 'G')
        g1.addEdge('D', 'H')
        g1.addEdge('B', 'E')
        g1.addEdge('B', 'F')
        g1.addEdge('E', 'I')
        console.log(g1.toString());

        let result = ''
        g1.bfs(g1.vertexes[0], (v) => {
            result += v + '=='
        })
        console.log(result);

        let res = ''
        g1.dfs(g1.vertexes[0], (v) => {
            res += v + '=='
        })
        console.log(res);
```

### 大O表示法

![常见的大O表示法](/img/sample/a011/15. 常见的大O表示法.png)

大O表示法的推导方法

> 用常量1取代运行时间中所有的加法常量
> 在修改后的运行次数函数中，只保留最高项
> 如果最高项存在且常数不为1，则去除与这个项相乘的常数

### 排序算法

简单排序：

> 冒泡排序
> 选择排序
> 插入排序

高级排序：

> 希尔排序

![希尔排序思路](/img/sample/a011/16. 希尔排序思路.png)

> 增量 N/2
>
> 快速排序

为什么需要排序？

> 对数据进行排序后可以更方便的对数据进行操作，如：查找、删除等

```javascript
        class ArrayList {
            array = []
            insert(item) {
                this.array.push(item)
            }
            toString() {
                return this.array.join('-')
            }
            swap(a, b) { //交换数据
                let temp = this.array[a]
                this.array[a] = this.array[b]
                this.array[b] = temp
            }
            bubbleSort() { //冒泡排序  交换最大值   交换次数O(N^2)  比较次数O(N^2)
                let length = this.array.length
                for (let j = length - 1; j >= 0; j--) {
                    for (let i = 0; i < j; i++) {
                        if (this.array[i] > this.array[i + 1]) {
                            this.swap(i, i + 1)
                        }
                    }
                }
            }
            selectionSort() { //选择排序  选择最小值  交换次数O(N)    比较次数O(N^2)
                let length = this.array.length
                for (let j = 0; j < length - 1; j++) {
                    let min = j //从index j 开始查找最小值
                    for (let i = min + 1; i < length; i++) {
                        if (this.array[min] > this.array[i]) {
                            min = i
                        }
                    }
                    this.swap(min, j)
                }
            }
            insertionSort() { //插入排序  局部有序   复制次数O(N^2/4) 比较次数O(N^2/4)
                let length = this.array.length
                for (let i = 1; i < length; i++) {
                    let temp = this.array[i]
                    let j = i
                    while (this.array[j - 1] > temp && j > 0) { //使用while循环因为不知道比较次数
                        this.array[j] = this.array[j - 1]
                        j--
                    }
                    this.array[j] = temp
                }
            }
            shellSort() { //希尔排序  分组局部有序   最坏情况下时间复杂度为O(N^2)
                let length = this.array.length
                let gap = Math.floor(length / 2) //增量
                while (gap >= 1) {
                    for (let i = gap; i < length; i++) {
                        let temp = this.array[i]
                        let j = i
                        while (this.array[j - gap] > temp && j > gap - 1) {
                            this.array[j] = this.array[j - gap]
                            j -= gap
                        }
                        this.array[j] = temp
                    }
                    gap = Math.floor(gap / 2)
                }
            }
            quickSort() { //快速排序  分而治之  选出一个数字 将小于自己的放在左边 将大于自己的放在右边  平均效率O(N*logN)
                this.quick(0, this.array.length - 1)
            }
            quick(left, right) { //快速排序递归函数
                if (left >= right) return
                let pivot = this.median(left, right) //枢纽
                let i = left - 1
                let j = right - 1
                while (true) {
                    while (this.array[++i] < pivot) {}
                    while (this.array[--j] > pivot) {}
                    if (i < j) {
                        this.swap(i, j)
                    } else {
                        break
                    }
                }
                this.swap(i, right - 1)
                this.quick(left, i - 1)
                this.quick(i + 1, right)
            }
            median(left, right) { //选择中位数，作为快速排序的枢纽
                let center = Math.floor((left + right) / 2)
                if (this.array[left] > this.array[center]) {
                    this.swap(left, center)
                }
                if (this.array[center] > this.array[right]) {
                    this.swap(center, right)
                }
                if (this.array[left] > this.array[right]) {
                    this.swap(left, right)
                }
                this.swap(center, right - 1)

                return this.array[right - 1]
            }
        }
        let arr = new ArrayList()
        arr.insert(29)
        arr.insert(56)
        arr.insert(1)
        arr.insert(100)
        arr.insert(12)
        arr.insert(79)
        // console.log(arr.toString());

        // arr.bubbleSort()
        // arr.selectionSort()
        // arr.insertionSort()
        // arr.shellSort()
        arr.quickSort()

        console.log(arr.toString());
```

---
参考视频：[BV1x7411L7Q7](https://www.bilibili.com/video/BV1x7411L7Q7?spm_id_from=333.999.0.0)
