---
title: js设计模式
categories:
  - 前端学习
tags:
  - 设计模式
date: 2023-03-11 12:17:27
index_img: https://img2.baidu.com/it/u=2339054325,339575289&fm=253&fmt=auto&app=138&f=JPEG?w=470&h=307
---

### 设计模式( Design Pattern)

### 什么是设计模式

设计模式是我们在解决问题的时候针对特定问题给出的简洁而优化的处理方案

### 构造器模式

```javascript
function Employee(name, age) {
    this.name = name
    this.age = age
    this.say = function() {
        console.log(this.name + '--' + this.age);
    }
}
const e1 = new Employee('jack', 25) //say需要重复创建，消耗内存
const e2 = new Employee('rose', 25)
```

### 原型模式

```javascript
 //原型模式
 function Employee(name, age) {
     this.name = name
     this.age = age
 }
 Employee.prototype.say = function() {
     console.log(this.name + '--' + this.age);
 }
 const e1 = new Employee('jack', 25)
 console.log(e1);

 //es6
 class Emplo {
     constructor(name, age) {
         this.name = name
         this.age = age
     }
     say() {
         console.log(this.name + '--' + this.age);
     }
 }
 const em1 = new Emplo('rose', 23)
 console.log(em1);
```

### 工厂模式

优点：只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道具体创建的细节
缺点：当对象数量很多时，这个函数会变成庞大的超级函数，难以维护

```javascript
 class User {
     constructor(role, auth) {
         this.role = role
         this.auth = auth
     }
     static UserFactor(role) {
         switch (role) {
             case 'super-admin':
                 return new User('super-admin', ['home', 'user-manage', 'right-manage', 'news-manage'])
             case 'admin':
                 return new User('admin', ['home', 'right-manage', 'news-manage'])
             case 'editor':
                 return new User('editor', ['home', 'news-manage'])
             default:
                 throw new Error('参数错误')
                 break;
         }
     }
 }
 const u = User.UserFactor('super-admin')
 console.log(u);
```

### 抽象工厂模式

抽象工厂模式并不直接生成实例，而是用于对产品类簇的创建，即返回对应的类

```javascript
     class User {
         constructor(name, role, auth) {
             this.name = name
             this.role = role
             this.auth = auth
         }
         welcome() {
             console.log('欢迎回来', this.name);
         }
         dataShow() {
             throw new Error('抽象方法需要被实现')
         }
     }
     class SuperAdmin extends User {
         constructor(name) {
             super(name, 'super-admin', ['home', 'user-manage', 'right-manage', 'news-manage'])
         }
         dataShow() {}
         addRight() {}
         addUser() {}
     }
     class Admin extends User {
         constructor(name) {
             super(name, 'admin', ['home', 'user-manage', 'news-manage'])
         }
         dataShow() {}
         addUser() {}
     }
     class Editor extends User {
         constructor(name) {
             super(name, 'editor', ['home', 'news-manage'])
         }
         dataShow() {}
     }

     function getAbstractUserFactory(role) {
         switch (role) {
             case 'super-admin':
                 return SuperAdmin
             case 'admin':
                 return Admin
             case 'editor':
                 return Editor
             default:
                 throw new Error('参数错误')
         }
     }
```

### 建造者模式

是一种创建复杂对象的方式，它将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
工厂模式和抽象工厂主要是为了创建实例或者类簇，关心最终产出的是什么，而不关心创建的过程
而建造者模式关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节

```javascript
      class Views {
          init() {
              console.log('views-init');
          }
          getData() {
              console.log('views-getdata');
          }
          render() {
              console.log('views-render');
          }
      }
      class Components {
          init() {
              console.log('components-init');
          }
          getData() {
              return new Promise((resolve) => {
                  setTimeout(() => {
                      resolve('components-data')
                  }, 1000)
              })
          }
          render() {
              console.log('components-render');
          }
      }
      class Creater {
          async startBuild(builder) {
              await builder.init()
              await builder.getData()
              await builder.render()
          }
      }

      const c1 = new Creater().startBuild(new Views())
      const c2 = new Creater().startBuild(new Components())
```

### 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点
主要解决一个全局使用的类频繁的创建和销毁，占用内存

```javascript
     //闭包形式
     let singleton = (() => {
         let instance

         class User {
             constructor(name, age) {
                 this.name = name
                 this.age = age
             }
         }

         return (name, age) => {
             if (!instance) {
                 instance = new User(name, age)
             }
             return instance
         }
     })()
     // console.log(singleton());
     // console.log(singleton('jack', 25) === singleton('rose', 26)); //说明instance没有被回收，被外部引用导致不会释放

     //es6写法
     class Singleton {
         constructor(name, age) {
             if (!Singleton.instance) {
                 this.name = name
                 this.age = age
                 Singleton.instance = this
             }
             return Singleton.instance
         }
         say() {}
     }
     console.log(new Singleton());
     console.log(new Singleton() === new Singleton('夹克', 23));
```

### 装饰器模式

装饰器模式能够很好的对已有的功能进行拓展，不会更改原有的代码，对其他业务产生影响
方便我们在较少的改动下对软件功能进行拓展

```javascript
       Function.prototype.before = function(beforeFn) {
           let _this = this //this为test
           return function() {
               //this为window
               beforeFn.apply(this, arguments) //arguments为test的参数
               return _this.apply(this, arguments)
           }
       }
       Function.prototype.after = function(afterFn) {
           let _this = this //this为ƒ () {beforeFn.apply(this, arguments)return _this.apply(this, arguments)}
           return function() {
               //this为window
               let res = _this.apply(this, arguments)
               afterFn.apply(this, arguments)
               return res
           }
       }

       function test() {
           console.log('1111');
       }
       // console.dir(test);

       //test = new Function
       test1 = test.before(() => {
           console.log('before');
       }).after(() => {
           console.log('after');
       })
       // console.log(test1);
       test1()
```

### 适配器模式

将一个类的接口转换成客户希望的另一个接口，适配器模式让那些接口不兼容的类可以一起工作

```javascript
     class TencentMap {
         show() {
             console.log('腾讯地图开始渲染');
         }
     }
     class GaodeMap {
         display() {
             console.log('高德地图开始渲染');
         }
     }
     class TencentAdapater extends TencentMap {
         constructor() {
             super()
         }
         display() {
             this.show()
         }
     }

     function renderMap(map) {
         map.display()
     }
     renderMap(new TencentAdapater())
     renderMap(new GaodeMap())
```

### 策略模式

策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户，易扩展
策略模式属于对象行为模式，通过对算法进行封装，把使用算法的责任和算法的实现分开，并委派给不同的对象对这些算法进行管理

```javascript
        const strategy = {
            'A': (salary) => {
                return salary * 4
            },
            'B': (salary) => {
                return salary * 3
            },
            'C': (salary) => {
                return salary * 2
            }
        }

        function calBonus(level, salary) {
            return strategy[level](salary)
        }
        console.log(calBonus('A', 10000));
```

### 代理模式

代理模式(proxy)，为其他对象提供一种代理以控制对这个对象的访问
使得代理对象控制具体对象的引用，代理几乎可以是任何对象：文件、资源、内存中的对象，或者是一些难以复制的东西

```javascript
       class Idol {
           dance() {
               console.log('唱跳rap');
           }
       }
       class IdolProxy {
           constructor() {
               this.idol = new Idol()
           }
           talk(price) {
               if (price >= 10000) {
                   this.idol.dance()
               }
               throw new Error('没排面')
           }
       }
       new IdolProxy().talk(10000)
       new IdolProxy().talk(1000)

       //proxy使用
       let zhiyin = {
           name: '鸡',
           price: 1000
       }
       let proxy = new Proxy(zhiyin, {
           get(target, key) {
               if (key === 'price') {
                   console.log('问了价钱');
               }
               return target[key]
           },
           set(target, key, value) {
               if (key === 'price' && value > target[key]) {
                   console.log('成交');
                   target[key] = value
               } else {
                   throw new Error('别来沾边')
               }
           }
       })
       // console.log(proxy.price);
       // proxy.price = 10000

       //精简版vue3
       let vm = {}
       let vueProxy = new Proxy(vm, {
           get(target, key) {
               return target[key]
           },
           set(target, key, value) {
               if (key === 'data') {
                   document.querySelector('.app').innerHTML = value //此处为vue内部操作dom
                   target[key] = value
               }
           }
       })
       document.querySelector('input[type="text"]').addEventListener('input', (event) => {
           vueProxy.data = event.target.value
       })
```

### 观察者模式

观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目与之相依赖的观察者
一旦观察目标的状态发生改变，所有的观察者都将得到通知
观察者和目标要相互知道
缺点：不能对时间通知进行细分管控，如筛选通知、指定主题事件通知

```javascript
        class Subject {
            constructor() {
                this.observers = []
            }
            add(ob) {
                this.observers.push(ob)
            }
            remove(ob) {
                this.observers = this.observers.filter(item => item !== ob)
            }
            notify() {
                this.observers.forEach(item => {
                    item.update()
                })
            }
        }
        class Observer {
            constructor(name) {
                this.name = name
            }
            update() {
                console.log(`update---${this.name}`);
            }
        }
        const s = new Subject()
        const ob1 = new Observer('jack')
        const ob2 = new Observer('rose')
        s.add(ob1)
        s.add(ob2)
        setTimeout(() => {
            s.remove(ob1)
        }, 1000)
        setTimeout(() => {
            s.notify()
        }, 2000)
```

### 发布订阅模式

发布者与订阅者不用相互知道，通过第三方实现调度，属于经过解耦合的观察者模式

```javascript
        const PubSub = { //调度中心
            message: {},
            publish(name, ...args) {
                if (!this.message[name]) return
                this.message[name].forEach(cb => cb(...args));
            },
            subscribe(name, cb) {
                if (!this.message[name]) {
                    this.message[name] = [cb]
                } else {
                    this.message[name].push(cb)
                }
            },
            unsubscribe(name, cb) {
                if (!cb) {
                    delete this.message[name]
                    // this.message[name] && (this.message[name].length = 0)
                } else {
                    this.message[name] = this.message[name].filter(item => item !== cb)
                }
            }
        }
        PubSub.subscribe('init', (...args) => {
            console.log(`init`, ...args);
        })
        PubSub.subscribe('refr', (...args) => {
            console.log(`refr`, ...args);
        })
        PubSub.unsubscribe('init')
        PubSub.publish('init', '000', 'aaa')
        PubSub.publish('init', '001')
        PubSub.publish('refr', '111', 'bbb')
        PubSub.publish('refr', '112')
```

### 模块模式

模块化模式最初被定义为在传统软件工程中为类提供私有和公共封装的一种方法
能够使一个单独的对象拥有公共、私有的方法和变量，从而屏蔽来自全局作用域的特殊部分，这可以减少我们的函数名与在页面中其他脚本区域内定义的函数名冲突的可能性

```javascript
        //闭包
        const obj = (function() {
            let count = 0
            return {
                increase() {
                    return ++count
                },
                decrease() {
                    return --count
                }
            }
        })()
        console.log(obj.increase());
        console.log(obj.decrease());

        //commonjs  AMD(requirejs)  CMD(seajs)  esModule
```

### 桥接模式

将抽象部分与它的实现部分分离，使它们都可以独立的变化
使用场景：一个类存在两个或者多个独立变化的维度，且这两个维度都需要扩展(技术栈之间的桥接，如：vue+animate.css)
优点：把抽象和实现隔离开，有助于独立管理各个组成部分
缺点：每使用一个桥接元素都要增加一次函数调用，这对应用程序的性能会有一些负面影响(提高了系统的复杂度)

```javascript
        //提示-动画类型
        const animation = {
            bounce: {
                show() {
                    console.log('bounce-show');
                },
                hide() {
                    console.log('bounce-hide');
                }
            },
            fade: {
                show() {
                    console.log('fade-show');
                },
                hide() {
                    console.log('fade-hide');
                }
            },
            rotate: {
                show() {
                    console.log('rotate-show');
                },
                hide() {
                    console.log('rotate-hide');
                }
            }
        }

        class Modal { //modal|toast|message
            constructor(el, animation) {
                this.el = el
                this.animation = animation
            }
            show() {
                this.animation.show()
            }
            hide() {
                this.animation.hide()
            }
        }
        const m = new Modal('*', animation.bounce)
        m.show()
        setTimeout(() => {
            m.hide()
        }, 1000)
```

### 组合模式

组合模式在对象间形成树形结构
组合模式中基本对象和组合对象一致对待
无需关心对象有多少层，调用时只需在根部调用

```javascript
        class Folder {
            constructor(folder) {
                this.folder = folder
                this.list = [] //保存子文件夹或文件
            }
            add(child) {
                this.list.push(child)
            }
            scan() {
                console.log('扫描文件夹', this.folder);
                this.list.forEach(child => child.scan())
            }
        }

        class File {
            constructor(file) {
                this.file = file
            }
            scan() {
                console.log('扫描文件', this.file);
            }
        }

        const rootfolder = new Folder('root')
        // console.log(rootfolder);

        const cssfolder = new Folder('css')
        const imgfolder = new Folder('img')
        const homecss = new File('home.css')
        const aboutcss = new File('about.css')
        const bg = new File('bg.png')

        rootfolder.add(cssfolder)
        rootfolder.add(imgfolder)
        cssfolder.add(homecss)
        cssfolder.add(aboutcss)
        imgfolder.add(bg)

        rootfolder.scan()
```

### 命令模式

有时候需要向某些对象发送请求，但并不知道请求的接受者是谁，也不知道被请求的的操作是什么。需要一种松耦合的方式来设计程序，使得发送者和接受者能够消除彼此之间的耦合关系
发布者(invoker)发出命令，调用命令对象，不知道如何执行与谁执行---客户
接受者(receiver)提供对应接口处理请求，不知道谁发起请求---仓库
命令对象(command)接收命令，调用接受者对应接口处理发布者的请求---订单

```javascript
        class Receiver {
            execute() {
                console.log('Receiver-execute');
            }
        }
        class Command {
            constructor(receiver) {
                this.receiver = receiver
            }
            execute() {
                console.log('Command-execute');
                this.receiver.execute()
            }
        }
        class Invoker {
            constructor(command) {
                this.command = command
            }
            order() {
                console.log('Invoker-execute');
                this.command.execute()
            }
        }
        const command = new Command(new Receiver())
        const client = new Invoker(command)
        client.order()

        //宏命令模式 = 命令模式+组合模式
        class MacroCommand {
            constructor() {
                this.list = [] //子命令
            }
            add(command) {
                this.list.push(command)
            }
            execute() {
                this.list.forEach(item => item.execute())
            }
        }
        class Tabs {
            execute() {
                console.log('选项卡执行');
                this.init()
                this.getData()
                this.render()
            }
            init() {
                console.log('Tabs-init');
            }
            getData() {
                console.log('Tabs-getData');
            }
            render() {
                console.log('Tabs-render');
            }
        }
        class Swiper {
            execute() {
                console.log('轮播执行');
                this.init()
                this.getData()
                this.render()
            }
            init() {
                console.log('Swiper-init');
            }
            getData() {
                console.log('Swiper-getData');
            }
            render() {
                console.log('Swiper-render');
            }
        }
        const m = new MacroCommand()
        m.add(new Tabs())
        m.add(new Swiper())
        m.execute()
```

### 模板方法模式

由两部分组成，第一部分是抽象父类，是个模板，第二部分是具体的实现子类
在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序
子类通过继承这个抽象类，继承了整个算法结构，并且可以重写父类的方法

```javascript
        //类似于抽象类或继承
        class Template {
            init() {
                let data = this.getData()
                this.render(data)
            }
            getData() {}
            render(data) {}
        }
        class Header extends Template {
            getData() {
                console.log('Header-getData');
                return [1, 2, 3]
            }
            render(data) {
                console.log('Header-render', data);
            }
        }
        const h = new Header()
        h.init()
```

### 迭代器模式

为遍历不同数据结构的‘集合’提供统一的接口
能遍历访问‘集合’数据中的项，不关心项的数据结构

```javascript
        function iterator(arr, callback) {
            for (let i = 0; i < arr.length; i++) {
                callback(arr[i], i)
            }
        }
        iterator(['a', 'b', 'c'], (item, index) => {
            let li = document.createElement('li')
            li.innerHTML = `<span>索引：${index}</span>  <b>${item}</b>`
            document.querySelector('.ul').appendChild(li)
        })

        //ES6
        const obj = { //遍历对象直接用forin,这里想要使用forof
            list: ['a', 'b', 'c'],
            [Symbol.iterator]() {
                let i = 0
                let arr = this.list
                return {
                    next: () => {
                        if (i < arr.length) {
                            return {
                                value: arr[i++],
                                done: false
                            }
                        } else {
                            return {
                                value: undefined,
                                done: true
                            }
                        }
                    }
                }
            }
        }
        const ite = obj[Symbol.iterator]()
        console.log(ite.next());
        console.log(ite.next());
        console.log(ite.next());
        console.log(ite.next());
        for (let item of obj) {
            console.log(item);
        }
```

### 职责链模式

使多个对象(接受者)都有机会处理请求，从而避免了请求的发送者与多个接受者直接的耦合关系
将这些接受者连成一条链，顺着这条链传递该请求，直接找到能处理该请求的对象
场景：作用域链，原型链，事件冒泡
优点：单一职责，方便扩充
缺点：出错不好排查，需要从链头开始查找

```javascript
        //未使用职责链
        let value
        document.querySelector('button').addEventListener('click', () => {
            return
            value = document.querySelector('input').value
            console.log(value);
            if (value.length === 0) {
                console.log('不能为空');
            } else {
                if (Number.isNaN(+value)) {
                    console.log('必须是数字');
                } else {
                    if (value.length < 6) {
                        console.log('大于6位');
                    }
                }
            }
        })

        //使用职责链
        function checkEmty() {
            if (value.length === 0) {
                console.log('不能为空');
                return
            }
            return 'next'
        }

        function checkNumber() {
            if (Number.isNaN(+value)) {
                console.log('必须是数字');
                return
            }
            return 'next'
        }

        function checkLength() {
            if (value.length < 6) {
                console.log('大于6位');
                return
            }
            return 'next'
        }
        class Chain {
            constructor(fn) {
                this.checkRule = fn
                this.nextRule = null
            }
            addRule(nextRule) {
                this.nextRule = new Chain(nextRule)
                return this.nextRule
            }
            check() {
                (this.checkRule() === 'next') && this.nextRule.check()
                // this.checkRule() === 'next' ? this.nextRule.check() : null
            }
        }
        const chain0 = new Chain(checkEmty)
        chain0
            .addRule(checkNumber)
            .addRule(checkLength)
            .addRule({
                check: () => console.log('通过验证')
            })

        document.querySelector('button').addEventListener('click', () => {
            value = document.querySelector('input').value
            chain0.check()
        })
```

---
参考视频：千峰[BV1MP4y127kd](https://www.bilibili.com/video/BV1MP4y127kd/)