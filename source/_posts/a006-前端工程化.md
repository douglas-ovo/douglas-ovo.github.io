---
title: 前端工程化
categories:
  - 前端学习
tags:
  - 模块化
  - 组件化
date: 2022-07-11 17:51:41
index_img: https://img1.baidu.com/it/u=2232393801,2549850796&fm=253&fmt=auto&app=138&f=JPG?w=500&h=438
---
## 工程化
前端工程化是一个高层次的思想,而模块化和组件化是为工程化思想下相对较具体的开发方式,因此可以简单的认为模块化和组件化是工程化的表现形式。

## 模块化篇
模块化开发，一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。
将一个复杂的程序依据一定的规范封装成几个块，并进行组合在一起。
块内部数据是私有的，只是向外部暴露一些接口与外部其它模块通信。

**发展史：**
  >namespace(简单封装)，本质是对象，一点不安全
  >IIFE模式(匿名闭包)，利用立即执行函数，然后暴露
  >IIFE增强模式，当前模块化的基础
  
**优点：**
  >避免命名冲突(减少命名空间污染)
  >更好的分离, 按需加载
  >更高复用性
  >高可维护性

**缺点：**
  >需要很多的script标签
  >请求过多
  >依赖模糊
  >难以维护

**规范：**
  >common.js
  >AMD规范
  >CMD规范
  >es6规范


### common.js
每个文件都可当作一个模块，常用于服务器端
在服务器端: 模块的加载是运行时同步加载的(node)
在浏览器端: 模块需要提前编译打包处理(Browserify工具)，浏览器不认识require

  ```javascript
  /* 
  暴露模块   
  暴露的本质都是导出expors对象 
  */
  module = {
      exports:{}
  }

  /* 
  引入模块
  第三方模块：xxx为模块名(包名),放在文件最上面
  自定义模块：xxx为模块文件路径 
  */
  require(xxx)
  ```


### AMD规范 require.js
专门用于浏览器端, 模块的加载是异步的

  ```javascript
  /* 
  导出
  */
  define(function() {})                               //定义没有依赖的模块
  define(['module1','module2'],function(m1,m2){})     //定义有依赖的模块

  /* 
  导入 
  */
  requirejs(['module3'],function(m3) {})
  requirejs.config({                                  //配置数组中模块加载路径：
      baseUrl:'js/'                                   //不写模块路径相对于main.js,写的话相当于根路径下js+模块路径
      paths:{
          module1:'./module1',                        //不用加js后缀，默认已经加上了
          module2:'./module2',
          module3:'./module3',
          jquery:'./jQuery 1.11.1'                    //jquery要小写且支持amd规范
      }
  })
  ```
  ```html
  <!-- 最后引入的时候使用一个script标签即可 -->
  <script data-main='main.js' src='require.js'></script> 
  ```


### CMD规范 Sea.js
专门用于浏览器端, 模块的加载是异步的 
模块使用时才会加载执行

  ```javascript
  /* 
  导出
  */
  define(function(require,exports,module) {
    //module.exports = xxx
    exports.a = xxx
  })

  /* 
  引入 
  */  
  define(function(exports) {
      //同步引入
      let module1 = require('./module1')               //引入最后拿到这个模块暴露的东西，但是模块上面的代码也会执行
      //异步引入
      require.async('./module2',function(module2) {
        module2.foo()
      })
      exports.b = xxx
  })
  ```
  ```html
  <!-- 使用 -->
  <script src='Sea.js'></script>                       <!-- 先引入 -->
  <script>Seajs.use('main.js')</script>                <!-- 后使用 -->
  ```


### es6规范
依赖模块需要编译打包处理，很多浏览器不支持es6语法，需要编译打包成es5
  ```javascript
  /* 
  具名导出 
  */
  export value                                        //分别暴露
  export {value,value}                                //统一暴露
  //引入：
  import {名字1,名字2} from 路径    
  //或
  import * as 变量名 from 路径    
  //或
  import {名字1,名字2 as 自定义名字} from 路径          //具名导出，引入的时候必须使用对象解构赋值的方式 

  /* 
  统一导出 
  */
  export default value                                //一个模块中只能用一次

  /* 
  引入 
  */
  import 自定义名字 from 路径                          //引用第三方库，就是这种方式 
  ``` 

实现(浏览器端)
  >使用Babel将es6编译成es5代码(里面有commonjs的语法)，使用browserify编译打包js
  >配置.babelrc ,rc run control运行时控制文件


## 组件化篇
页面上的每个独立的、可视/可交互区域视为一个组件;
每个组件对应一个工程目录,组件所需的各种资源都在这个目录下就近维护;
由于组件具有独立性,因此组件与组件之间可以 自由组合;
页面只不过是组件的容器,负责组合组件形成功能完整的界面;
当不需要某个组件,或者想要替换组件时,可以整个目录删除/替换。

---
参考视频：[BV18s411E7Tj](https://www.bilibili.com/video/BV18s411E7Tj?spm_id_from=333.1007.top_right_bar_window_history.content.click)
参考博客：[https://www.cnblogs.com/angel648/p/11370327.html](https://www.cnblogs.com/angel648/p/11370327.html)